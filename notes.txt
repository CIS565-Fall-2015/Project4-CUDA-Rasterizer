add:
-anti-aliasing
-tessellation shader + wireframe shading OR instancing
-tile based pipeline

TESSELATION
-every triangle gets an "innter" value and 4 "outer" values
-wat

INSTANCING [working]
-we'll do it two ways
	-serial instancing: multiple draws between buffer wipes
	-parallel instancing: allocates more memory every time number of instances changes
		-more memory in the primitives buffer
		-add new kernels for parallel instancing
		
-btw there's a problem where the fragment shader doesn't work on lab machines. wtf.

ANTIALIASING
-seems like the way MSAA works is:
	-compute 5 samples per fragment
	-but only compute fragment shading on the center
	-use that value for each occluded sample
	-and then average the samples for a color
	-it's cheating antialiasing!
	-for frags with more than one triangle... bad luck, must compute more times. worst case is 5x per frag, so worst case is like FSAA

-TODO:
-add a struct for AAfrag [done]
-add a new AAdepth_buffer [done]
-add a new AArender [done]
-add a new AAscanline [done]
-add fragment shaders [done]
-add antialiasing to rasterize() [done]

TILING
-need to tile scanline and fragment shading
-so need to make shared memory versions of each
-need to use syncthreads()
-go look at how the work efficient version was done

TODO:
-add a spatial datastructure
	-we'll need one for each tile (yikes)
	-each needs room to hold a list of every primitive (yikes)
	-so spatial datastructure size and allocation all needs to be done in one go
	-also need a fast kernel to "dump" transformed primitives into each structure
	-also will need to add a special destruction handler to destroy each list (yikes)
-add a new tiled scanline and AAscanline (yikes)
	-basically, uses shared memory
	-so needs to clip to smaller coordinate area, use lower resolution
	-fractional tiles are OK - be sure to handle this
-ditto with fragment shading
